var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#TriLayout","page":"API","title":"TriLayout","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TriMatrices.TriLayout\nTriUpper\nTriLower\nTriSymmetric\nTriMatrices.hasdiag\nTriMatrices.nelems\nTriMatrices.transpose_layout","category":"page"},{"location":"api/#TriMatrices.TriLayout","page":"API","title":"TriMatrices.TriLayout","text":"abstract type TriLayout\n\nAbstract type which indicates which regions of a TriMatrix are stored in memory. Type parameter is a Bool indicating whether the matrix diagonal is stored.\n\n\n\n\n\n","category":"type"},{"location":"api/#TriMatrices.TriUpper","page":"API","title":"TriMatrices.TriUpper","text":"struct TriUpper{D} <: TriMatrices.TriLayout{D}\n\nThe upper triangle of the matrix is stored, values beneath the diagonal are zero.\n\n\n\n\n\n","category":"type"},{"location":"api/#TriMatrices.TriLower","page":"API","title":"TriMatrices.TriLower","text":"struct TriLower{D} <: TriMatrices.TriLayout{D}\n\nThe lower triangle of the matrix is stored, values above the diagonal are zero.\n\n\n\n\n\n","category":"type"},{"location":"api/#TriMatrices.TriSymmetric","page":"API","title":"TriMatrices.TriSymmetric","text":"struct TriSymmetric{D} <: TriMatrices.TriLayout{D}\n\nMatrix is symmetric across the diagonal, one value is stored for each pair of non-diagonal entries.\n\n\n\n\n\n","category":"type"},{"location":"api/#TriMatrices.hasdiag","page":"API","title":"TriMatrices.hasdiag","text":"hasdiag(::Type{<:TriLayout})::Bool\nhasdiag(layout::TriLayout)::Bool\n\nCheck if the given layout/layout type stores values along the diagonal.\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.nelems","page":"API","title":"TriMatrices.nelems","text":"nelems(::Type{<:TriLayout}, n)::Integer\nnelems(layout::TriLayout, n)::Integer\n\nGet the number of elements needed to store the data of a TriMatrix with the given layout.\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.transpose_layout","page":"API","title":"TriMatrices.transpose_layout","text":"transpose_layout(::Type{<:TriLayout})\ntranspose_layout(layout::TriLayout)\n\nGet the TriLayout of the transpose of a TriMatrix with the given layout.\n\nThis maps TriUpper and TriLower to each other, and TriSymmetric to itself.\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrix","page":"API","title":"TriMatrix","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TriMatrix\nTriMatrix(::TriMatrices.TriLayout, ::Integer, ::AbstractVector)\nTriMatrix(::TriMatrices.TriLayout, ::UndefInitializer, ::Integer)\nTriMatrix(::TriMatrices.TriLayout, ::AbstractMatrix)\nBase.fill(::Any, ::TriMatrices.TriLayout, ::Integer)\nBase.ones(::Type, ::TriMatrices.TriLayout, ::Integer)\nBase.zeros(::Type, ::TriMatrices.TriLayout, ::Integer)\nTriMatrices.TriLayout(::TriMatrix)\nBase.parent(::TriMatrix)\nTriMatrices.getindex_tri_unsafe\nTriMatrices.setindex_tri_unsafe!","category":"page"},{"location":"api/#TriMatrices.TriMatrix","page":"API","title":"TriMatrices.TriMatrix","text":"struct TriMatrix{T, L<:TriMatrices.TriLayout, A} <: AbstractArray{T,2}\n\nA triangular or symmetric matrix which stores data non-redundantly in a contiguous linear array.\n\n\n\n\n\n","category":"type"},{"location":"api/#TriMatrices.TriMatrix-Tuple{TriMatrices.TriLayout,UndefInitializer,Integer}","page":"API","title":"TriMatrices.TriMatrix","text":"TriMatrix{T}(layout::TriLayout, undef, n::Integer; diag=zero(T))\nTriMatrix(layout::TriLayout, undef, n::Integer; diag=0.)\n\nCreate an uninitialized n by n TriMatrix.\n\nT defaults to Float64 if not specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#TriMatrices.TriMatrix-Tuple{TriMatrices.TriLayout,AbstractArray{T,2} where T}","page":"API","title":"TriMatrices.TriMatrix","text":"TriMatrix{T}(layout::TriLayout, m::AbstractMatrix; diag=zero(T))\nTriMatrix(layout::TriLayout, m::AbstractMatrix; [diag])\n\nCreate a TriMatrix by copying data from a square matrix m.\n\nIf unspecified T defaults to eltype(m).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.fill-Tuple{Any,TriMatrices.TriLayout,Integer}","page":"API","title":"Base.fill","text":"fill(x, layout::TriLayout, n::Integer; diag=x)\n\nCreate an n by n TriMatrix with the stored data region filled with the value x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ones-Tuple{Type,TriMatrices.TriLayout,Integer}","page":"API","title":"Base.ones","text":"ones(T::Type=Float64, layout::TriLayout, n::Integer; diag=x)\n\nCreate an n by n TriMatrix with the stored data region filled with ones.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.zeros-Tuple{Type,TriMatrices.TriLayout,Integer}","page":"API","title":"Base.zeros","text":"zeros(T::Type=Float64, layout::TriLayout, n::Integer; diag=x)\n\nCreate an n by n TriMatrix with the stored data region filled with zeros.\n\n\n\n\n\n","category":"method"},{"location":"api/#TriMatrices.TriLayout-Tuple{TriMatrix}","page":"API","title":"TriMatrices.TriLayout","text":"TriMatrices.TriLayout(m::TriMatrix)\n\nGet the TriLayout of the given TriMatrix instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parent-Tuple{TriMatrix}","page":"API","title":"Base.parent","text":"parent(m::TriMatrix)\n\nGet the underlying data array of the TriMatrix m.\n\n\n\n\n\n","category":"method"},{"location":"api/#TriMatrices.getindex_tri_unsafe","page":"API","title":"TriMatrices.getindex_tri_unsafe","text":"getindex_tri_unsafe(mat::TriMatrix, i::Integer, j::Integer) -> Any\n\n\nGet the value of an element within the stored data region of a TriMatrix. Should be faster than Base.getindex (even with @inbounds applied) but results are undefined if check_tri_index(mat, i, j) does not pass.\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.setindex_tri_unsafe!","page":"API","title":"TriMatrices.setindex_tri_unsafe!","text":"setindex_tri_unsafe!(mat::TriMatrix, v::Any, i::Integer, j::Integer) -> Any\n\n\nSet the value of an element within the stored data region of a TriMatrix. Should be faster than Base.setindex! (even with @inbounds applied) but results are undefined if check_tri_index(mat, i, j) does not pass.\n\n\n\n\n\n","category":"function"},{"location":"api/#Indexing","page":"API","title":"Indexing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TriMatrices.Indexing.check_tri_index\nTriMatrices.Indexing.car2lin\nTriMatrices.Indexing.car2lin_unchecked\nTriMatrices.Indexing.lin2car\nTriMatrices.Indexing.tri_indices\nTriMatrices.Indexing.TriIndexIterator\nTriMatrices.Indexing.trinum\nTriMatrices.Indexing.triinv\nTriMatrices.Indexing.triinv_strict\nTriMatrices.Indexing.triinv_rem","category":"page"},{"location":"api/#TriMatrices.Indexing.check_tri_index","page":"API","title":"TriMatrices.Indexing.check_tri_index","text":"check_tri_index(Bool, layout::TriLayout, i, j)::Bool\ncheck_tri_index(Bool, layout::TriLayout, idx::CartesianIndex{2})::Bool\n\nCheck whether a row/column index is within the stored region of a TriMatrix with the given layout. Assumes the index is otherwise valid for the corresponding matrix size.\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.Indexing.car2lin","page":"API","title":"TriMatrices.Indexing.car2lin","text":"car2lin(layout::TriLayout, i::Integer, j::Integer)\ncar2lin(layout::TriLayout, idx::CartesianIndex{2})\n\nConvert Cartesian row/column indices of a TriMatrix with the given layout to a linear index of its data array.\n\nThis function is the inverse of lin2car.\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.Indexing.car2lin_unchecked","page":"API","title":"TriMatrices.Indexing.car2lin_unchecked","text":"car2lin_unchecked(layout::TriLayout, i::Integer, j::Integer)\ncar2lin_unchecked(layout::TriLayout, idx::CartesianIndex{2})\n\nLike car2lin, but somewhat faster because it does not check that the index is within the data region of the matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.Indexing.lin2car","page":"API","title":"TriMatrices.Indexing.lin2car","text":"lin2car(layout::TriLayout, i::Integer)\n\nConvert linear index of the data array of a TriMatrix with the given layout to the corresponding Cartesian index.\n\nThis function is the inverse of car2lin.\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.Indexing.tri_indices","page":"API","title":"TriMatrices.Indexing.tri_indices","text":"tri_indices(layout::TriLayout, n::Integer)\n\nIterate over the cartesian indices of a TriMatrix corresponding to the linear indices of its data array, in order.\n\nThis should be equivalent to the following generator expression:\n\n(lin2car(layout, i) for i in 1:nelems(layout, n))\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.Indexing.TriIndexIterator","page":"API","title":"TriMatrices.Indexing.TriIndexIterator","text":"Iterator over Cartesian indices of the stored region of a TriMatrix in an order corresponding to the elements of its data array. Created with the tri_indices function.\n\n\n\n\n\n","category":"type"},{"location":"api/#TriMatrices.Indexing.trinum","page":"API","title":"TriMatrices.Indexing.trinum","text":"trinum(n::Integer) -> Any\n\n\nGet the nth triangular number.\n\nSee also\n\ntriinv\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.Indexing.triinv","page":"API","title":"TriMatrices.Indexing.triinv","text":"triinv(t::Integer) -> Any\n\n\nGet the largest n such that t >= trinum(n).\n\nSee also\n\ntriinv_strict, trinum\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.Indexing.triinv_strict","page":"API","title":"TriMatrices.Indexing.triinv_strict","text":"triinv_strict(t::Integer) -> Any\n\n\nGet n such that t is the nth triangular number. If t is not a triangular number, throw a DomainError.\n\nSee also\n\ntriinv, trinum\n\n\n\n\n\n","category":"function"},{"location":"api/#TriMatrices.Indexing.triinv_rem","page":"API","title":"TriMatrices.Indexing.triinv_rem","text":"triinv_rem(t::Integer) -> Tuple{Any,Any}\n\n\nGet n and r >= 0 such that t == trinum(n) + r and t < trinum(n + 1).\n\nSee also\n\ntriinv, trinum\n\n\n\n\n\n","category":"function"},{"location":"#TriMatrices.jl","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"","category":"section"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"TriMatrix is a subtype of AbstractMatrix which stores only the values on one side of the diagonal, thus reducing the memory required by about half. The data is stored in an underlying 1D array. It is intended for large matrices where the amount of memory saved is significant.","category":"page"},{"location":"#Layouts","page":"TriMatrices.jl","title":"Layouts","text":"","category":"section"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"The TriMatrix type is parameterized by subtype of TriMatrices.TriLayout which determines how the elements of the underlying data array are mapped to the 2D matrix. This is one of TriUpper, TriLower, or TriSymmetric.","category":"page"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"This is illustrated by using a unit range for the data array:","category":"page"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"julia> n = 4\n\njulia> data = 1:10\n\njulia> TriMatrix(TriUpper(), n, data)\n4×4 TriMatrix{Int64,TriUpper{true},UnitRange{Int64}}:\n 1  2  4   7\n ⋅  3  5   8\n ⋅  ⋅  6   9\n ⋅  ⋅  ⋅  10\n\njulia> TriMatrix(TriLower(), n, data)\n4×4 TriMatrix{Int64,TriLower{true},UnitRange{Int64}}:\n 1  ⋅  ⋅   ⋅\n 2  3  ⋅   ⋅\n 4  5  6   ⋅\n 7  8  9  10\n\njulia> TriMatrix(TriSymmetric(), n, data)\n4×4 TriMatrix{Int64,TriSymmetric{true},UnitRange{Int64}}:\n 1  2  4   7\n 2  3  5   8\n 4  5  6   9\n 7  8  9  10","category":"page"},{"location":"#Creating-TriMatrix-instances","page":"TriMatrices.jl","title":"Creating TriMatrix instances","text":"","category":"section"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"In the below examples, the size of the resulting matrix is n by n.","category":"page"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"Wraping an existing data array (as shown above): TriMatrix(layout::TriLayout, n, data::AbstractVector)\nUninitialized with eltype T: TriMatrix{T=Float64}(layout::TriLayout, undef, n)\nCopied from an existing square matrix m: TriMatrix{T=eltype(m)}(layout::TriLayout, m::AbstractMatrix)\nFilled with ones: ones(T::Type=Float64, layout::TriLayout, n), same for zeros\nFilled with the value x: fill(x, layout::TriLayout, n)","category":"page"},{"location":"#Matrices-with-constant-diagonal","page":"TriMatrices.jl","title":"Matrices with constant diagonal","text":"","category":"section"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"TriLayout subtypes have a single boolean type parameter which indicates whether elements along the diagonal are explicitly stored along with the rest (true, the default) or filled with a constant value (false). For the 2nd case, constructor methods take a diag keyword argument to set this value:","category":"page"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"julia> TriMatrix(TriUpper{false}(), 4, 1:6; diag=-1)\n4×4 TriMatrix{Int64,TriUpper{false},UnitRange{Int64}}:\n -1   1   2   4\n  ⋅  -1   3   5\n  ⋅   ⋅  -1   6\n  ⋅   ⋅   ⋅  -1","category":"page"},{"location":"","page":"TriMatrices.jl","title":"TriMatrices.jl","text":"This can be used with TriSymmetric{false} and diag=0 or diag=1 for a distance or correlation matrix, respectively, or with TriUpper{false}/TriLower{false} and diag=1 for a unit triangular matrix. The diag argument can also be passed to functions like ones, zeros, and fill. It defaults to zero.","category":"page"}]
}
